### [ 소프트웨어 개발 ]

### 1. 데이터 입출력 구현
    1. 자료 구조
        - 선형 : 데이터 연속적, 리스트, 스택LIFO, 큐FIFO, 데크(양 끝에서 삽입, 제거 가능)
        - 비선형 : 데이터 비연속적, 트리, 그래프
    2. 비선형 - 트리 구조
        - 인덱스 조작
        - 순회
            - 전위 : CLR
            - 중위 : LCR
            - 후위 : LRC
        - 균형 잡는 트리 종류
            - AVL , 2-3, 레드-블랙
    3. 그래프 탐색 방법
        - DFS 깊이 우선 탐색 : 깊이 다음 옆
        - BFS 너비 우선 탐색 :  옆 다음 깊이
### 2. 통합 구현
    1. 단위 모듈 구현
        - 기능을 단위 모듈별 분할
        - 성능 향상
        - 유지보수 효과적
        - 독립적인 기능을 갖는 단위
        - 인터페이스, 데이터베이스 접근 모듈 통햡 구현에 필요한 컴포넌트 구현
    2. 단위 모듈 구현 원리
        - *정분추모*
        - 정보은닉
        - 분할 및 정복
        - 데이터 추상화
        - 모듈 독립성
    3. 모듈 컴포넌트 차이
        - 컴포넌트는 런타임에 독립적으로 배포되고 실행(ex 서버1, 클라이언드5)
        - 모듈은 정적인 구조(ex 서버, 클라이언트) 소프트웨어나 하드웨어의 일부
        - 모듈은 구조의 최소 단위, 정적인 구조를 가지고 
        컴포넌트는 런타임에 독립적으로 배포되고 실행 되는 단위
    4. 프로그래밍 언어 선택 시 고려사항
        - 개발 정보시스템의 특성, 사용자의 요구사항, 컴파일러의 가용성
    5. 재사용 Reuse 기법 종류
        - 재공학 Re-Engineering
            - 기존 SW 기능 개선, 재활용
            - 위험부담 감소, 비용 절감, 개발 기간 단축, 시스템 명세의 오류억제
            - 분석, 재구조, 역공학, 이식
        - 재개발 Re-Development
            - 참조하여 완전히 새로운 시스템 개발
            - 기능 추가, 기능 변경
    6. 단위 모듈 테스트 IDE(Integrated Development Environment) 도구 사용
        - 모듈 작동 확인
        - 오류 찾는 작업 ( Debug 디버그 오류 수정 작업 )
    7.  단위 모듈 테스트 종류
        - 명세 기반(블랙박스) 테스트 : 요구사항 명세서 기반
        - 구조 기반(화이트박스) 테스트 : 소스 코드 보며 TC(test case) 기반
    8.  형상 관리
        - SW cycle 동안 변경 사항을 체계적으로 관리
        - 프로젝트 요구 분석서, 소스 코드, 운영 및 설치 지침서
        - 유지보수, 개발 단계 모두 사용 가능
    9.  형상 관리 절차
        - *식통감기*
    10. 형상 관리 도구 사례
        - *CSG*
        - CVS(Computer Versions System)
            - 중앙 집중형 서버 저장소, 클라이언트 버전 관리
            - 직관적, 단순한 명령
            - 롤백 기능 미지원
        - SVN(Subversion)
            - 중앙 집중형 클라이언트-서버
            - CVS 보완, 롤백 기능 지원
            - 물리적 저장 위치 점유
            - 개별 개발자만의 개발 이력을 가질 수 없음
        - Git
            - 저장소의 완전한 복사본 로컬 저장 가능
            - 이력 관리 쉬움
            - 대용량 코드 부적절
            - diff 명령어로 한번에 보기 어려움
### 3.  제품 소프트웨어 패키징
    1. Application packaging 특징
        - 사용자 중심, 편의성, 버전 관리, 릴리즈 노트
    2. 사용자 관점에서 패키징 고려사항
        - *환유관변*
        - 사용자 시스템 환경 정의
        - UI 제공
        - 관리 서비스 형태로 제공
        - 패키징의 변경 및 개선 관리 고려
    3. Application 배포 도구 기술요소
        - *암키식저 파정크인*
        - 암호화, 키 관리, 식별 기술, 저작권 표현
        - 암호화 파일 생성, 정책 관리, 크랙 방지, 인증
    4. Application 배포 도구 활용 시 고려사항
        - *암이복최*
        - 암호화/보안, 이기종 연동, 복잡성 및 비효율성 문제, 최적합 암호화 알고리즘 적용
    5. DRM(Digital Rigths Management)
        - 권리정보 지정, 암호화 기술로 허가된 사용자가 허가된 범위의 콘텐츠 이용
        - DRM 구성요소(저작권 관리 구성 요소) : 제공자, 소비자, 분배자, 클리어링 하우스, 콘텐츠, 패키저, 컨트롤러, 보안 컨테이너로 구성
        - 분배자는 제공자에게 받아 소비자에게 유통
    6. DRM 기술요소
        - *암키식저 파크정인*
    - 국제 제품 품질 표준
    7. ISO/IEC 9126
        - *기신사 효유이*
        - 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성
    8. ISO/IEC 14598
        - *반재공객*
        - 반복성, 재현성, 공정성, 객관성
    9. 국제 프로세스 품질 표준
        - 9001 : 설계 및 서비스 과정
        - 12207 : 관리
        - 15504(SPICE) : 평가 개선
        - CMMi : 개발 능력/성숙도 평가 개선, 조직(단계별 표현) 프로세스영역(연속적 표현)
    10. ISO/IEC 25000 (SQuaRE)
        - 9126 + 14598 ⇒ SW 품질 평가 모델 국제 표준
        - 구조 : *관모측요평* (관리, 모델, 측정, 요구, 평가)
    11. SW Engineering
        - 개발, 운용, 유지보수, 파기에 대한 접근 방법
        - sw 위기 극복을 위한 방안으로 연구된 학문
        - 현대적 기술 적용
        - 품질 유지, 지속적 검증 수행
        - 명확한 기록 유지
        - 유지보수 용이, 신뢰성, 테스팅
    12. SW Engineering 관련 법칙
        - Brook’s : 인력 추가 방해된다
        - Pareto : 20%의 모듈에서 80%의 결함 발견된다
        - Long Tail : 파레토 반대, 사소한 80%가 핵심 20% 보다 뛰어난 가치 창출한다
    13. SW version 관리 도구
        - RCS : 공유 폴더
        - CVS, SVN : 클라이언트-서버
        - Git : 분산 저장소
    14. 빌드 자동화 구성 요소
        - *CS 빌테커인*
        - CI 서버, SCM, 빌드 도구, 테스트 도구, 테스트 커버리지 도구, 인스펙션 도구
### 4.  애플리케이션 테스트 관리
    1. 테스트 오라클(Test Oracle)
        - 참 거짓 판단, 사전 정의된 참 값과 비교
    2. 테스트 오라클 종류
        - *참샘휴일*
        - 참(True) : 모든 입력 값에 대한 결과 생성, 발생된 오류 모두 검출
        - 샘플링(Sampling) : 특정 몇 개 입력 값
        - 휴리스틱(Heuristic) : 샘플링 개선, 나머지 값들에 대해서 추정 처리
        - 일관성 검사(Consistent) : App 변경 시 전 후 결과 값 동일 여부 확인
    3. 테스트 레벨
        - 함께 편성, 관리되는 테스트 활동의 그룹
        - 프로젝트에서 책임과 연관
        - 각각의 레벨은 독립적
        - SW 개발 단계 생명주기 V-model
    4. 테스트 레벨 종류
        - *단통시인*
        - 단위 : 인터페이스, 자료구조, 실행 경로, 오류 처리
        - 통합 : 빅뱅, 상/하양식
        - 시스템 : 기능/비기능 요구사항
        - 인수 : 알파/베타
    5. 단위 테스트(Unit Test)
        - 모듈, 컴포넌트에 초점
        - 자료 구조, 인터페이스, 외부적I/O, 독립적 기초 경로, 오류 처리 경로, 경계 조건을 검사
        - 명세 기반(블랙), 구조 기반(화이트) 로 나누지만 주로 구조 기반 테스트
    6. 통합 테스트(Integartion Test)
        - 모듈 간의 인터페이스 관련 오류 및 결함 찾기, 체계적
        - 단위 테스트 후 동일한 구조와 기능으로 구현된 것인지 확인
    7. 시스템 테스트(System Test)
        - 기능이 시스템에서 정상 동작 확인
        - 완벽 검사 목표
        - 기능적, 비기능적
    8. 인수 테스트(Acceptance Test)
        - 사용자 테스트
        - 개발된 제품에 대한 운영 여부 결정
        - 특정한 비기능적 특성
        - 알파(선택된 사용자가 개발자 환경에서 개발자와 함께), 베타(=필드 테스팅, 실제 환경에서 개발자 없이)
    9. 프로그램 실행 여부에 따른 분류
        - 정적 : 리뷰, 정적 분석
        - 동적 : 명세(블랙 박스) 기반, 구조(화이트 박스) 기반, 경험(탐색적, 오류추정) 기반
    10. Black-box Test(명세)
        - 요구사항 명세서 기반 기능 테스트
        - 기능 동작 위주, 구조나 원리 몰라도 가능
        - 유형 10가지 ( *동경결상 유분페원비오* )
        - 동등 분할, 경곗값 분석, 결정 테이블, 상태전이, 유스케이스, 분류 트리, 페어와이즈, 원인-결과 그래프, 비교, 오류 추정
    11. White-box Test(구조)
        - 프로그램 내부 구조와 동작 검사
        - 코드 분석, 구조 지식 바탕
        - 모든 소스 코드 수행
        - (=구조기반, 코드기반, 로직기반, 글래스박스)
        - 유형 10가지 ( *구결조 조변다 기제데루* )
        - 구문(문장), 결정(선택), 조건, 조건-결정, 변경 조건-결정, 다중 조건, 기본 경로(경로), 제어 흐름(+구결조 조변다, 통칭), 데이터 흐름, 루프
    12. 테스트 목적에 따른 분류
        - *회안성 강 구회병*
        - 회복, 안전, 성능, 강도, 구조, 회귀, 병행
    13. SW 테스트의 원리
        - *결완초집 살정오*
        - 결함 존재 증명, 완벽 테스팅 불가, 초기 집중, 결함 집중, 살충제 패러독스, 정황 의존, 오류-부재의 궤변
    14. 테스트 자동화 도구 유형
        - 정적 분석 도구 : 앱 실행하지 않고 분석
        - 테스트 실행 도구 : 스크립트 수행
        - 성능 테스트 도구 : 성능 확인
        - 테스트 통제 도구 : 형상 관리
        - 테스트 장치 : 테스트 지원하는 코드와 데이터
    15. 테스트 장치 구성 요소
        - *드스슈 케시스목*
        - 드라이버 Driver : 상향식, 가상의 모듈로 하위 모듈을 호출
        - 스텁 Stub : 하향식, 임시 모듈로 상위 모듈에 의해 호출됨
        - 슈트 Suite : TC 집합, 시나리오가 포함되지 않는 단순한 TC들
        - 케이스 Case : 입력값, 실행 조건, 기대 결과 등
        - 시나리오 Scenario : 테스트가 필요한 상황을 작성, 시나리오:TC=일:다
        - 스크립트 Script : 실행순서
        - 목 Mock : 사용자 행위를 조건부로 사전에 입력, 에정된 행위 수행
    16. 컴파일 vs 런타임
        - 정적 분석에서 가능함
        - 컴파일 : 문법, 타입, 무한 루프
        - 런타임 : 0 나누기 , Null 참조
    17. 통합 테스트
        - 모듈간의 상호작용
        - 하양식 : Stub깊이우선, 너비식
        - 상향식 : Driver최하위→최상위
    18. 알고리즘 기법
        - *분동탐백*
        - 분할과 정복, 동적계획법, 탐욕법, 백트래킹
    19. 시간 복잡도에 따른 알고리즘
        - O(1) : 상수형, 자료 크기 무관, 입력데이터 수와 무관하게 수행시간 일정
            - 해시 함수 Hash Funtion
        - O(log2n) : 로그형, 문제 해결 단계수 log2n 수행시간
            - 이진 탐색 Binary Search
        - O(n) : 선형, 차례대로 모두 처리, 수행시간 자료 크기 정비례
            - 순차 탐색 Sequential Search
        - O(nlong2n) : 선형 로그형, 문제 해결 단계수 nlong2n수행시간
            - 퀵 정렬, 병합 정렬, 힙 정렬
        - O(n2) : 제곱형, 루프 구조 2중, n작을 때는 n2이 nlong2n보다 빠름
            - 거품 정렬, 삽입 정렬, 선택 정렬
    20. 해싱함수 Hashing Funtion
        - 데이터를 키로 변환
        - *산곱숫 폴기무*
        - 제산법(Division) 제곱법(Mid Square) 숫자 분석법(Digit Analysis)
        폴딩법(Folding)-XOR(배타적 논리합) 기수 변환법(Radix Conversion) 무작위 방법(Random)
        - 계산과정의 단순화, 충돌 최소화, 기억 장소 낭비 최소화, 오버플로우 초소화 고려
    21. 검색 알고리즘
        - 순차 Sequntial Search : 배열 검색
        - 이진 Binary Search : 탐색 범위 절반씩 좁혀감(M = (F+L)/2)

    22. 정렬 알고리즘

    - 퀵 Quick Sort : 왼쪽 피벗보다 작은 값을 오른쪽에 둠, 최적O(nlong2n), 평균O(nlong2n), 최악O(n2)
    - 합병 Merge Sort : 하나의 단위로 분할→합병→정렬, 최적O(nlong2n), 평균O(nlong2n), 최악O(nlong2n)
    - 힙 HeapSort : 가장 큰 키값 루트 노드를 제거 반복, 완전이진트리(Complete Binary Tree), 최적O(nlong2n), 평균O(nlong2n), 최악O(nlong2n)
    - 거품 Bubble Sort : 인접한 2개의 키값 비교, 위치 교환, 모든 숫자 정렬 횟수 = 요소개수-1
    - 삽입 Insert Sort : 2번째 키와 첫번째 키 비교→순서대로 나열
    - 선택 Selection Sort : 가장 작은 데이터를 찾아 정렬되지 않은 앞 데이터와 자리 교환
    - ⇒ O(nlong2n) 퀵.병.힙 / O(n2) 거.삽.선
    23. 소스 코드 품질 분석 도구
        - 정적
        - pmd : 자바 및 타 언어 소스 코드에 대한 버그 데드 코드 분석
        - cppcheck : C/C++ 메모리 누수, 오버플로우 분석
        - SonarQube : 소스 코드 품질 통합 플랫폼, 플러그인 확장가능
        - checkstyle : 자바, 표준 검사
        - ccm : 다양한 언어, 코드 복잡도 분석, 리눅스, 맥 환경 cli 형태
        - cobertura : jcoverage 테스트 커버리지 측정
        - 동적
        - Avalanche : Valgrind 프레임워크 및 STP 기반 sw error 및 취약점 분석
        - Valgrind : 자동화된 메모리 및 스레드 결함 발견 분석
    24. 맥케이브 회전 복잡도(McCabe Cyclonmatic Complexity)
        - sw 제어 흐름 그래프, 코드 복잡도 정량적
        - 정량적 지표, 구조적 평가, 간접 방식
        - V(G) = E - N + 2 복잡도V(G) 는 노드(N), 간선(E) 수로 계산
        - V(G) = P + 1 복잡도V(G) 는조건 분기문(P) 수로 계산
    25. 클린 코드
        - *가단의 중추*
        - 가독성, 단순, 낮은 의존성, 중복 최소화, 추상화
    26. 배드 코드
        - 오염, 문서 부족, 의미 없는 이름, 높은 결합도, 아키텍처 침식, 외계인 코드, 스파게티 코드, 알 수 없는 변수명, 로직 중복
### 5.  인터페이스 구현
    1. 인터페이스 기능은 이기종 시스템 또는 컴포넌트 간 데이터 교환 및 처리를 위한 기능
    2. EAI (Enterprise Application Interation)
        - 서로 다른 플랫폼 및 애플리케이션 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션
        - 비즈니스 간 통합 및 연계성 증대, 효율성, 확장성
        - EAI 구축 유형
            - *포허 메하*
            - 포인트 투 포인트(Point-to-Point) : 미들웨어 없음, 점대점 연결
            - 허브 앤 스포크(Hub & Spoke) : 접점 허브, 중앙 집중식, 허브 장애 시 전체 장애
            - 메시지 버스(Message Bus) : 미들웨어, 확장성, 대용량 데이터 처리
            - 하이브리드(Hybrid) : 그룹 내부 허브, 그룹 간은 메시지 버스 방식
    3. ESB (Enterprise Service Bus)
        - 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영, 서비스 중심의 통합
        - 버스 중심으로 각각 프로토콜 호환 가능, 낮은 결합 방식
            - 낮은 결합 : 특정 서비스를 변경하더라도 연결된 다른 서비스에는 영향을 주지 않는 유연한 구조
    4. 시큐어 코딩 가이드
       - *입보시 에코캡아*

        |  |  |  |
        | --- | --- | --- |
        | **입력 데이터 검증 및 표현** | 입력값 누락, 잘못된 형식 | 유효성 검증 |
        | **보안 기능** | 보안 기능 부적절 | 적절한 보안 설계 및 구현 |
        | **시간 및 상태** | 병렬 시스템, 관리 부적절 | 직렬화, 병렬 실행 가능 프레임워크 사용, 블록문 내에 재귀 함수 |
        | **에러 처리** | 에러 메시지에 중요 정보 포함 | 약점 생기지 않게 설계 및 구현 |
        | **코드 오류** |  |  |
        | **캡슐화** | 데이터 누출 | 프라이빗 접근자 지정 |
        | **API 오용** |  | 취약 api 검출 프로그램 사용 |
    5. 데이터베이스 암호화 알고리즘
        - *대비해*
        - 대칭 키 : 암.복호화
        - 비대칭 키 : 공개키, 비밀키
        - 해시 : 일방향성
    6. 데이터베이스 암호화 기법
        - *애플하APH*
        - API : App 수정 방식, 암.복호화, 정책 관리, 키 관리 부하 발생
        - Plug-in : DB 프로시저 기능 사용, 암.복호화, 정책 관리, 키 관리 부하 발생
        - Hybrid : API+Plug-in, 부하 분산
    7. 중요 인터페이스 데이터의 암호화 전송 보안 기술

        |  |  |
        | --- | --- |
        | **IPSec (IP Security)** | 1. IP계층(3계층)에서 무결성, 인증 보장하는 인증헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용 2. 양방향 암호화 3. 동작 모드 : 전송Transport, 터널Tunnel 4. 주요 프로토콜 : AH, IKE(키교환), IPSec 정책에는 SPD, SAD -인증 프로토콜 AH - 암호화 프로토콜 ESP - 키 관리 프로토콜 IKE |
        | **SSL/TLS** | 1. 전송계층(4계층), 응용계층(7계층) 사이에서 클라이언트-서버 웹데이터 암호화, 무결성 보장 2. 인증 모드 : 익명, 서버 인증, 클C-서S인증 3. C-S상호 인증 4. 특정 암호 기술에 의존 하지 않음 5. https://~, 443 port |
        | **S-HTTP (Secure Hypertext Transfer Protocol)** | 1. web 네트워크 트래픽 암호화 2. C-S 간의 메시지 암호화 3.  HTTP를 사용한 App만 보호 가능 |

    8. 인터페이스 데이터 포멧
        - JSON, XML, YAML
        - JSON : 비동기 브라우저/서버 통신(AJAX)을 위해 key-value, object, 인간 리딩 가능
        - XML : W3C에서 개발, 마크업 언어
        - YAML : 사람이 쉽게 읽을 수 있는 형태로 표현, 직렬화
    9.  인터페이스 구현 검증 도구 종류
        - *엑스핏 엔셀웨*

        |  |  |
        | --- | --- |
        | **xUnit** | 1. Java(jUnit), C++(cppUnit), .Net(nUnit), Web(httpUnit), 다양한 언어 지원 2. 단위 테스트 프레임워크 |
        | **STAF** | 1. 서버 호출, 컴포넌트 재사용, 다양한 환경 지원 2. 자동화 검증 도구 |
        | **FitNesse** | 1. 웹 기반 지원 2. 사용자가 TC table작성 → 자동으로 원하는 값에 대한 테스트 가능 |
        | **NTAF** | 1. STAF + FitNesse, 자동화 2. STAF 분산 환경 지원+ FItNesse TC 디자인, 레포팅 |
        | **Selenium** | 1. 다양한 브라우저, 개발언어 지원, 웹앱 테스트 2. 테스트 스크립트 언어 학습 불필요 3. 기능 테스트를 위한 플레이백 도구 제공 |
        | **watir** | 1. Ruby 기반 웹앱 테스트 2. 모든 언어 기반의 웹앱 테스트와 브라우저 호환성 테스팅 가능 |
